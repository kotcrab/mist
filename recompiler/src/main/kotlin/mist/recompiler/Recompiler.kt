package mist.recompiler

import kio.util.child
import kio.util.toHex
import kio.util.toWHex
import mist.asm.*
import mist.asm.mips.FpuReg
import mist.asm.mips.GprReg
import mist.asm.mips.MipsInstr
import mist.asm.mips.MipsOpcode
import mist.asm.mips.allegrex.AllegrexDisassembler
import mist.asm.mips.allegrex.AllegrexOpcode
import mist.asm.mips.allegrex.Vfpu
import mist.ghidra.GhidraClient
import mist.ghidra.model.GhidraFunction
import mist.ghidra.model.GhidraSymbol
import mist.ghidra.model.GhidraType
import mist.io.BinLoader
import mist.module.ModuleMemory
import mist.recompiler.TypeCast.*
import java.io.File
import java.nio.charset.Charset

class Recompiler(
  private val codeOutDir: File,
  private val memoryOutDir: File,
  outName: String,
  private val failOnUnsupportedOpcode: Boolean = false,
  private val additionalHeaders: Set<String> = emptySet(),
  private val functionPreHooks: Set<String> = emptySet(),
  private val functionPostHooks: Set<String> = emptySet(),
  private val reImplementedFunctions: Set<String> = emptySet(),
  private val reImplementedTypedFunctions: Set<String> = emptySet(),
  private val emptyFunctionAtAddresses: Set<Int> = emptySet(),
) {
  companion object {
    private const val DO_NOT_MODIFY_WARNING = "// Do not modify. This file is automatically generated."
    private const val CALL_ARGS_DEFINITION = "Context* ctx, Memory* mem"
    private const val CALL_ARGS = "ctx, mem"
    private const val CALL_INDIRECT = "_CallIndirect"
    private const val RUNTIME_LOG = "RUNTIME_LOG"
    private const val RUNTIME_PANIC = "RuntimePanic"
    private const val CTX_LO = "ctx->lo"
    private const val CTX_HI = "ctx->hi"
    private const val CTX_FCOND = "ctx->fpu.fcond"
    private const val TEMP64_TO_LO_HI = "$CTX_LO = (u32)temp64;\n$CTX_HI = (u32)(temp64 >> 32);"

    private val gprFunctionArgs = listOf(GprReg.A0, GprReg.A1, GprReg.A2, GprReg.A3, GprReg.T0, GprReg.T1, GprReg.T2, GprReg.T3)
    private val fpuFunctionArgs = listOf(FpuReg.F12, FpuReg.F13, FpuReg.F14, FpuReg.F15, FpuReg.F16, FpuReg.F17, FpuReg.F18, FpuReg.F19)
  }

  private val mainHeaderName = "${outName}.h"

  private val ghidraClient = GhidraClient.default()

  private val ghidraFunctions by lazy {
    ghidraClient.getFunctions()
      .sortedBy { it.entryPoint }
  }

  private val ghidraSymbols by lazy {
    ghidraClient.getSymbols()
  }

  private val ghidraTypes by lazy {
    ghidraClient.getTypes().associateBy { it.pathName }
  }

  private val initialMemory = ghidraClient.getMemoryBlocks()
    .filter { it.initialized && it.addressSpaceName == "ram" }
    .map { it.start.toInt() to ghidraClient.getMemory(it.start, it.size.toInt()) }

  init {
    println("Preparing output directories...")
    codeOutDir.mkdir() // TODO need to delete unused source files
    memoryOutDir.deleteRecursively()
    memoryOutDir.mkdir()
    if (!codeOutDir.exists() || !memoryOutDir.exists()) {
      error("Output directories does not exist")
    }

    println("Validating and dissembling functions...")
    checkFunctionConfig()
    checkAddressRanges(ghidraFunctions)
    checkDuplicateNames(ghidraFunctions)
    val disasm = AllegrexDisassembler()
    val loader = ModuleMemory.fromData(initialMemory).loader
    val disasmFuncs = ghidraFunctions.associateWith { func ->
      val funcDef = FunctionDef(func.compatibleName(), func.minAddress().toInt(), (func.maxAddress() - func.minAddress() + 1).toInt())
      disasm.disassemble(loader, funcDef).instrs
    }
    disasmFuncs.forEach { (_, instrs) ->
      checkJumpTables(ghidraSymbols, instrs)
    }

    println("Processing functions...")
    val typedReimplementations = reImplementedTypedFunctions
      .associateWith { name ->
        createTypedReimplementation(ghidraFunctions.first { it.name == name })
      }
    val outFuncs = processFunctions(loader, disasmFuncs, typedReimplementations)

    println("Writing main header...")
    writeMainHeader(typedReimplementations.values)

    println("Writing files...")
    writeIndirectSource()
    outFuncs.forEach { (objectName, funcs) ->
      println("Writing $objectName...")
      writeSource(objectName, funcs)
    }
    println("Writing initial memory...")
    initialMemory.forEach { (start, data) ->
      val fileName = "${start.toWHex()}.bin"
      println("Writing: $fileName...")
      memoryOutDir.child(fileName).writeBytes(data)
    }
  }

  private fun checkFunctionConfig() {
    (reImplementedFunctions + reImplementedTypedFunctions + functionPreHooks + functionPostHooks).forEach { name ->
      if (ghidraFunctions.none { it.name == name }) {
        error("No such function to reimplement: $name")
      }
    }
    (emptyFunctionAtAddresses).forEach { address ->
      if (ghidraFunctions.none { it.entryPoint.toInt() == address }) {
        error("No such function to generate empty implementation at: ${address.toWHex()}")
      }
    }
  }

  private fun writeMainHeader(typedReimplementations: Collection<TypedReimplementation>) {
    codeOutDir.child(mainHeaderName).writeTextIfDifferent(
      """$DO_NOT_MODIFY_WARNING

#pragma once

#include "types.h"
#include "runtime.h"
${additionalHeaders.joinToString("\n") { "#include \"${it}\"" }}

void $CALL_INDIRECT($CALL_ARGS_DEFINITION, u32 addr);

${ghidraFunctions.joinToString("\n\n") { "// ${it.entryPoint.toInt().toHex()}\nvoid ${it.compatibleName()}($CALL_ARGS_DEFINITION);" }}

// Typed reimplementations
${typedReimplementations.joinToString("\n\n") { it.toDefinitionCode() }}

// Pre-hooks
${
        functionPreHooks.map { name -> ghidraFunctions.first { it.name == name } }
          .joinToString("\n\n") { "void ${it.compatibleName()}_preHook($CALL_ARGS_DEFINITION);" }
      }

// Post-hooks
${
        functionPostHooks.map { name -> ghidraFunctions.first { it.name == name } }
          .joinToString("\n\n") { "void ${it.compatibleName()}_postHook($CALL_ARGS_DEFINITION);" }
      }
"""
    )
  }

  private fun writeIndirectSource() {
    codeOutDir.child("_indirect.cpp").writeTextIfDifferent(
      """$DO_NOT_MODIFY_WARNING

#include "$mainHeaderName"

void $CALL_INDIRECT($CALL_ARGS_DEFINITION, u32 addr) {
  switch(addr) {
${
        ghidraFunctions
          .joinToString("\n") { "case ${it.entryPoint.toInt().toHex()}:\n  ${it.compatibleName()}($CALL_ARGS);\n  return;" }
          .prependIndent("    ")
      }
    default:
      $RUNTIME_PANIC("Unknown function for indirect call");
    }
}
"""
    )
  }

  private fun writeSource(
    objectName: String,
    funcs: List<RecompiledFunction>
  ) {
    codeOutDir.child("${objectName}.cpp").writeTextIfDifferent(
      """$DO_NOT_MODIFY_WARNING

// ReSharper disable CppCStyleCast, CppDeclaratorNeverUsed, CppJoinDeclarationAndAssignment, CppRedundantControlFlowJump

#include <cmath>

#include "$mainHeaderName"

${funcs.joinToString("\n\n") { it.toCode() }}
"""
    )
  }

  private fun processFunctions(
    loader: BinLoader,
    disasmFuncs: Map<GhidraFunction, List<MipsInstr>>,
    typedReimplementations: Map<String, TypedReimplementation>,
  ): Map<String, List<RecompiledFunction>> {
    val outFuncs = mutableMapOf<String, MutableList<RecompiledFunction>>()
    disasmFuncs
      .filter { (func, _) -> func.name !in reImplementedFunctions }
      .forEach { (func, instrs) ->
        println("Processing ${func.name}...")
        val recompiledFunctions = outFuncs.getOrPut(func.targetObjectName()) { mutableListOf() }
        when {
          func.name in reImplementedTypedFunctions -> {
            println("INFO: Replacing function ${func.name} with a typed reimplementation")
            recompiledFunctions.add(
              RecompiledFunction(RecompiledFunction.Mode.TYPED_REIMPLEMENT, func, typedReimplementation = typedReimplementations[func.name])
            )
          }
          func.entryPoint.toInt() in emptyFunctionAtAddresses -> {
            println("INFO: Replacing function ${func.name} with an empty implementation")
            recompiledFunctions.add(RecompiledFunction(RecompiledFunction.Mode.EMPTY_BODY, func))
          }
          instrs.any { it.hasFlag(Vfpu) } -> {
            println("INFO: Function ${func.name} using VFPU instructions must be reimplemented")
            recompiledFunctions.add(RecompiledFunction(RecompiledFunction.Mode.WARN_VFPU, func))
          }
          instrs.size == 2 &&
            instrs[0].opcode == MipsOpcode.Jr && instrs[0].op0AsReg() == GprReg.Ra &&
            instrs[1].opcode == MipsOpcode.Nop &&
            !func.name.startsWith("nop_") && !func.name.endsWith("_nop") -> {
            recompiledFunctions.add(RecompiledFunction(RecompiledFunction.Mode.WARN_NO_OP, func))
          }
          else -> {
            recompiledFunctions.add(
              RecompiledFunction(
                RecompiledFunction.Mode.RECOMPILE,
                func,
                recompileInstructions(loader, func, instrs, postHook = functionPostHooks.contains(func.name)),
                preHook = functionPreHooks.contains(func.name)
              )
            )
          }
        }
      }
    return outFuncs
  }

  private fun createTypedReimplementation(ghidraFunction: GhidraFunction): TypedReimplementation {
    return TypedReimplementation(
      ghidraFunction,
      convertTypesToReimplementationArgs(ghidraFunction.parameters.map { it.dataTypePathName }),
      ReimplementationResult(ghidraTypes.getValue(ghidraFunction.returnTypePathName))
    )
  }

  private fun convertTypesToReimplementationArgs(pathNames: List<String>): List<ReimplementationArg> {
    val gprArgsIterator = sequence {
      var aligned = true
      for (arg in gprFunctionArgs) {
        yield(arg to aligned)
        aligned = !aligned
      }
    }.iterator()
    val fpuArgsIterator = sequence {
      for (arg in fpuFunctionArgs) {
        yield(arg)
      }
    }.iterator()
    val stackOffsetIterator = sequence {
      var stackOffset = 0
      var aligned = true
      while (true) {
        yield(stackOffset to aligned)
        stackOffset += 4
        aligned = !aligned
      }
    }.iterator()

    return pathNames.map {
      val type = ghidraTypes.getValue(it)

      fun nextAlignedArgRegs64(): ReimplementationArg.Regs? {
        val (arg, aligned) = gprArgsIterator.next()
        return when {
          aligned -> ReimplementationArg.Regs(type, arg, gprArgsIterator.next().first)
          gprArgsIterator.hasNext() -> ReimplementationArg.Regs(type, gprArgsIterator.next().first, gprArgsIterator.next().first)
          else -> null
        }
      }

      fun nextAlignedArgStack64(): ReimplementationArg.Stack {
        val (arg, aligned) = stackOffsetIterator.next()
        return when {
          aligned -> ReimplementationArg.Stack(type, arg, 8)
          else -> ReimplementationArg.Stack(type, stackOffsetIterator.next().first, 8)
        }
      }

      when {
        type.pathName == "/float" -> ReimplementationArg.Regs(type, fpuArgsIterator.next(), null)
        type.length == 4 -> when {
          gprArgsIterator.hasNext() -> ReimplementationArg.Regs(type, gprArgsIterator.next().first, null)
          else -> ReimplementationArg.Stack(type, stackOffsetIterator.next().first, 4)
        }
        type.length == 8 -> nextAlignedArgRegs64() ?: nextAlignedArgStack64()
        else -> error("Unsupported type length for argument ${type.length}, type is $type")
      }
    }
  }

  private fun checkDuplicateNames(funcs: List<GhidraFunction>) {
    val result = funcs.groupBy { it.compatibleName() }
      .filter { it.value.size > 1 }
      .onEach { (compatibleName, funcs) ->
        println("$compatibleName: ${funcs.map { it.name }}")
      }
    if (result.isNotEmpty()) {
      error("Duplicate compatible names must be fixed before recompiling")
    }
  }

  private fun checkJumpTables(symbols: List<GhidraSymbol>, instrs: List<MipsInstr>) {
    instrs.forEach { instr ->
      if (instr.opcode == MipsOpcode.Jr && instr.op0AsReg() != GprReg.Ra) {
        if (symbols.find { it.address.toInt() == instr.addr } == null) {
          println("WARN: Missing symbol for likely switch at $instr")
        }
      }
    }
  }

  private fun checkAddressRanges(funcs: List<GhidraFunction>) {
    val minAddress = funcs.first().minAddress()
    var lastAddress = minAddress
    println("Min address: ${minAddress.toInt().toWHex()}")
    funcs
      .forEach { func ->
        if (func.minAddress() != lastAddress) {
          println("WARN: Gap detected in functions: ${lastAddress.toInt().toWHex()} to ${func.minAddress().toInt().toWHex()}")
        }
        if (func.minAddress() != func.entryPoint) {
          error("Entry point mismatch, min address: ${func.minAddress().toInt().toWHex()}, entry point: ${func.entryPoint.toInt().toWHex()}")
        }
        lastAddress = func.maxAddress() + 1
      }
    println("Max address: ${lastAddress.toInt().toWHex()}")
  }

  private fun createPostHookCode(ghidraFunction: GhidraFunction, postHook: Boolean): String {
    if (!postHook) {
      return ""
    }
    return "${ghidraFunction.compatibleName()}_postHook($CALL_ARGS);\n"
  }

  private fun recompileInstructions(
    loader: BinLoader,
    ghidraFunction: GhidraFunction,
    instrs: List<MipsInstr>,
    postHook: Boolean
  ): List<RecompiledInstr> {
    val labels = mutableSetOf<Int>()
    val switches = mutableMapOf<Int, RecoveredSwitch>()
    val funcMinAddress = ghidraFunction.minAddress()
    val funcMaxAddress = ghidraFunction.maxAddress()
    val postHookCode = createPostHookCode(ghidraFunction, postHook)

    instrs.forEach { instr ->
      if (instr.hasFlag(Branch)) {
        labels.add(instr.branchTakenPc())
      } else if (instr.opcode == MipsOpcode.J) {
        labels.add(instr.op0AsImm())
      } else if (instr.opcode == MipsOpcode.Jr && instr.op0AsReg() != GprReg.Ra) {
        val instructionSymbol = ghidraSymbols.find { it.address.toInt() == instr.addr }
          ?: error("Missing symbol for switch at $instr")

        val dataSymbol = if (instructionSymbol.source == "USER_DEFINED") {
          // manually defined switch table
          val dataSymbolName = "manualSwitchTable_${instr.addr.toWHex()}"
          ghidraSymbols.find { it.name == dataSymbolName }
            ?: error("Missing data symbol for switch for instruction $instr, looking for symbol named $dataSymbolName")
        } else {
          // auto discovered switch table
          ghidraSymbols.find { it.name.startsWith("switchdata") && it.namespace == instructionSymbol.namespace }
            ?: error("Missing data symbol for auto discovered switch for instruction $instr, looking for symbol namespace $instructionSymbol")
        }
        var dataOffset = dataSymbol.address.toInt()
        val cases = mutableListOf<SwitchCase>()
        while (true) {
          val targetAddress = loader.readInt(dataOffset)
          if (targetAddress != 0 && (targetAddress < funcMinAddress || targetAddress > funcMaxAddress)) {
            break
          }
          cases.add(SwitchCase(cases.size, targetAddress))
          labels.add(targetAddress)
          dataOffset += 4
        }
        switches[instr.addr] = RecoveredSwitch(dataSymbol.address.toInt(), cases.filter { it.targetAddress != 0 })
      }
    }

    val recompiledInstrs = mutableListOf<RecompiledInstr>()
    val instrsIterator = instrs.iterator()
    while (instrsIterator.hasNext()) {
      val instr = instrsIterator.next()
      val delaySlotInstr = if (instr.hasFlag(DelaySlot)) instrsIterator.next() else null
      recompiledInstrs.add(RecompiledInstr(instr, recompileInstruction(instrs, instr, delaySlotInstr, switches, postHookCode), instr.addr in labels))
    }
    return recompiledInstrs
  }

  private fun recompileInstruction(
    instrs: List<MipsInstr>,
    instr: MipsInstr,
    delaySlotInstr: MipsInstr?,
    switches: Map<Int, RecoveredSwitch>,
    postHookCode: String,
  ): String {
    if (instr.hasFlag(DelaySlot)) {
      if (delaySlotInstr == null) {
        error("Instruction in delay slot must be provided when recompiling instruction with delay slot")
      }
    } else {
      if (delaySlotInstr != null) {
        error("Instruction in delay slot provided but instruction doesn't have a delay slot")
      }
    }

    fun recompileDelaySlotInstr(): String {
      return "${recompileInstruction(instrs, delaySlotInstr!!, null, switches, postHookCode)} // delay slot $delaySlotInstr"
    }

    fun recompileBranch(
      condition: String,
      firstArgument: String = instr.op0AsCode(S32),
      secondArgument: String = instr.op1AsCode(S32)
    ): String {
      val branchTakenPc = instr.branchTakenPc()
      val hasTarget = instrs.any { it.addr == branchTakenPc }
      if (!hasTarget) {
        println("WARN: Missing label for branch instruction $instr")
      }
      return """branchCond = ($firstArgument $condition $secondArgument);
${recompileDelaySlotInstr()}
if (branchCond) {
  ${if (hasTarget) "goto l_${branchTakenPc.toHex()}" else "$RUNTIME_PANIC(\"Unknown branch target\")"};
}"""
    }

    fun recompileBranchLikely(
      condition: String,
      firstArgument: String = instr.op0AsCode(S32),
      secondArgument: String = instr.op1AsCode(S32)
    ): String {
      val branchTakenPc = instr.branchTakenPc()
      val hasTarget = instrs.any { it.addr == branchTakenPc }
      if (!hasTarget) {
        println("WARN: Missing label for branch likely instruction $instr")
      }
      return """if ($firstArgument $condition $secondArgument) {
  ${recompileDelaySlotInstr()}
  ${if (hasTarget) "goto l_${branchTakenPc.toHex()}" else "$RUNTIME_PANIC(\"Unknown branch likely target\")"};
}"""
    }

    // Unsupported instructions: sync, ll, sc, syscall, bitrev, rotr, rotrv, eret, bitrev, wsbh, wsbw, mtc0, mfc0, cfc1, ctc1,
    // bltzal, bltzall, bgezal, bgezall, many of FPU compares, VFPU
    return when (instr.opcode) {
      // Arithmetic
      MipsOpcode.Add, MipsOpcode.Addu, MipsOpcode.Addi, MipsOpcode.Addiu -> "${instr.op0AsCode()} = ${instr.op1AsCode()} + ${instr.op2AsCode()};"
      MipsOpcode.Sub, MipsOpcode.Subu -> "${instr.op0AsCode()} = ${instr.op1AsCode()} - ${instr.op2AsCode()};"

      MipsOpcode.Mult -> "temp64 = ${instr.op0AsCode(S64)} * ${instr.op1AsCode(S64)};\n$TEMP64_TO_LO_HI"
      MipsOpcode.Multu -> "temp64 = ${instr.op0AsCode(U64)} * ${instr.op1AsCode(U64)};\n$TEMP64_TO_LO_HI"
      MipsOpcode.Div -> "$CTX_LO = ${instr.op0AsCode(S32)} / ${instr.op1AsCode(S32)};\n" +
        "$CTX_HI = ${instr.op0AsCode(S32)} % ${instr.op1AsCode(S32)};"
      MipsOpcode.Divu -> "$CTX_LO = ${instr.op0AsCode()} / ${instr.op1AsCode()};\n" +
        "$CTX_HI = ${instr.op0AsCode()} % ${instr.op1AsCode()};"
      MipsOpcode.Mflo -> "${instr.op0AsCode()} = $CTX_LO;"
      MipsOpcode.Mfhi -> "${instr.op0AsCode()} = $CTX_HI;"
      MipsOpcode.Mtlo -> "$CTX_LO = ${instr.op0AsCode()};"
      MipsOpcode.Mthi -> "$CTX_HI = ${instr.op0AsCode()};"

      MipsOpcode.Ins -> {
        val pos = instr.op2AsImm()
        val size = instr.op3AsImm()
        val rsMask = -1 ushr (32 - size)
        val rtMask = (rsMask shl pos).inv()
        "${instr.op0AsCode()} = (${instr.op0AsCode()} & ${rtMask.toHex()}) | ((${instr.op1AsCode()} & ${rsMask.toHex()}) << $pos);"
      }
      MipsOpcode.Ext -> {
        val pos = instr.op2AsImm()
        val size = instr.op3AsImm()
        "${instr.op0AsCode()} = (${instr.op1AsCode()} << ${32 - pos - size}) >> ${32 - size};"
      }

      MipsOpcode.Madd -> "temp64 = ((((u64)${CTX_HI}) << 32) | ${CTX_LO}) + (${instr.op0AsCode(S64)} * ${instr.op1AsCode(S64)});\n$TEMP64_TO_LO_HI"
      MipsOpcode.Msub -> "temp64 = ((((u64)${CTX_HI}) << 32) | ${CTX_LO}) - (${instr.op0AsCode(S64)} * ${instr.op1AsCode(S64)});\n$TEMP64_TO_LO_HI"
      MipsOpcode.Maddu -> "temp64 = ((((u64)${CTX_HI}) << 32) | ${CTX_LO}) + (${instr.op0AsCode(U64)} * ${instr.op1AsCode(U64)});\n$TEMP64_TO_LO_HI"
      MipsOpcode.Msubu -> "temp64 = ((((u64)${CTX_HI}) << 32) | ${CTX_LO}) - (${instr.op0AsCode(U64)} * ${instr.op1AsCode(U64)});\n$TEMP64_TO_LO_HI"

      AllegrexOpcode.Min -> "${instr.op0AsCode()} = ${instr.op1AsCode(S32)} < ${instr.op2AsCode(S32)} ? ${instr.op1AsCode()} : ${instr.op2AsCode()};"
      AllegrexOpcode.Max -> "${instr.op0AsCode()} = ${instr.op1AsCode(S32)} > ${instr.op2AsCode(S32)} ? ${instr.op1AsCode()} : ${instr.op2AsCode()};"

      // Logic
      MipsOpcode.And, MipsOpcode.Andi -> "${instr.op0AsCode()} = ${instr.op1AsCode()} & ${instr.op2AsCode()};"
      MipsOpcode.Or, MipsOpcode.Ori -> "${instr.op0AsCode()} = ${instr.op1AsCode()} | ${instr.op2AsCode()};"
      MipsOpcode.Xor, MipsOpcode.Xori -> "${instr.op0AsCode()} = ${instr.op1AsCode()} ^ ${instr.op2AsCode()};"
      MipsOpcode.Nor -> "${instr.op0AsCode()} = ~${instr.op1AsCode()};"

      // Shifts
      MipsOpcode.Sll, MipsOpcode.Sllv -> "${instr.op0AsCode()} = ${instr.op1AsCode()} << ${instr.op2AsCode()};"
      MipsOpcode.Srl, MipsOpcode.Srlv -> "${instr.op0AsCode()} = ${instr.op1AsCode()} >> ${instr.op2AsCode()};"
      MipsOpcode.Sra, MipsOpcode.Srav -> "${instr.op0AsCode()} = ${instr.op1AsCode(S32)} >> ${instr.op2AsCode(S32)};"

      // Set less than
      MipsOpcode.Slt, MipsOpcode.Slti -> "${instr.op0AsCode()} = ${instr.op1AsCode(S32)} < ${instr.op2AsCode(S32)} ? 1 : 0;"
      MipsOpcode.Sltu, MipsOpcode.Sltiu -> "${instr.op0AsCode()} = ${instr.op1AsCode()} < ${instr.op2AsCode()} ? 1 : 0;"

      // Memory
      MipsOpcode.Sb -> "mem->Write8(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Sh -> "mem->Write16(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Sw -> "mem->Write32(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Lb -> "${instr.op0AsCode()} = (s32)(s8)(mem->Read8(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}));"
      MipsOpcode.Lbu -> "${instr.op0AsCode()} = mem->Read8(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)});"
      MipsOpcode.Lh -> "${instr.op0AsCode()} = (s32)(s16)(mem->Read16(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}));"
      MipsOpcode.Lhu -> "${instr.op0AsCode()} = mem->Read16(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)});"
      MipsOpcode.Lw -> "${instr.op0AsCode()} = mem->Read32(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)});"

      MipsOpcode.Swl -> "mem->Write32L(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Swr -> "mem->Write32R(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Lwl -> "${instr.op0AsCode()} = mem->Read32L(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"
      MipsOpcode.Lwr -> "${instr.op0AsCode()} = mem->Read32R(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}, ${instr.op0AsCode()});"

      // FPU
      MipsOpcode.FpuAddS -> "${instr.op0AsCode()} = ${instr.op1AsCode()} + ${instr.op2AsCode()};"
      MipsOpcode.FpuSubS -> "${instr.op0AsCode()} = ${instr.op1AsCode()} - ${instr.op2AsCode()};"
      MipsOpcode.FpuMulS -> "${instr.op0AsCode()} = ${instr.op1AsCode()} * ${instr.op2AsCode()};"
      MipsOpcode.FpuDivS -> "${instr.op0AsCode()} = ${instr.op1AsCode()} / ${instr.op2AsCode()};"
      MipsOpcode.FpuMovS -> "${instr.op0AsCode()} = ${instr.op1AsCode()};"
      MipsOpcode.FpuNegS -> "${instr.op0AsCode()} = -${instr.op1AsCode()};"
      MipsOpcode.FpuAbsS -> "${instr.op0AsCode()} = fabsf(${instr.op1AsCode()});"
      MipsOpcode.FpuSqrtS -> "${instr.op0AsCode()} = sqrtf(${instr.op1AsCode()});"
      MipsOpcode.FpuCvtSW -> "${instr.op0AsCode()} = (float)(*(s32*)&${instr.op1AsCode()});"
      MipsOpcode.FpuCvtWS -> "*(s32*)(&${instr.op0AsCode()}) = (s32)roundf(${instr.op1AsCode()});" // ignoring rounding modes for now
      MipsOpcode.FpuRoundWS -> "*(s32*)(&${instr.op0AsCode()}) = (s32)roundf(${instr.op1AsCode()});"
      MipsOpcode.FpuTruncWS -> "*(s32*)(&${instr.op0AsCode()}) = (s32)${instr.op1AsCode()};"
      MipsOpcode.FpuCeilWS -> "*(s32*)(&${instr.op0AsCode()}) = (s32)ceilf(${instr.op1AsCode()});"
      MipsOpcode.FpuFloorWS -> "*(s32*)(&${instr.op0AsCode()}) = (s32)floorf(${instr.op1AsCode()});"
      MipsOpcode.FpuCEqS -> "$CTX_FCOND = ${instr.op0AsCode()} == ${instr.op1AsCode()};"
      MipsOpcode.FpuCLeS -> "$CTX_FCOND = ${instr.op0AsCode()} <= ${instr.op1AsCode()};"
      MipsOpcode.FpuCLtS -> "$CTX_FCOND = ${instr.op0AsCode()} < ${instr.op1AsCode()};"
      MipsOpcode.FpuMtc1 -> if (instr.op0AsReg() == GprReg.Zero) "${instr.op1AsCode()} = 0;" else "${instr.op1AsCode()} = *(float*)(&${instr.op0AsCode()});"
      MipsOpcode.FpuMfc1 -> "*(float*)(&${instr.op0AsCode()}) = ${instr.op1AsCode()};"
      MipsOpcode.Swc1 -> "*(float*)(mem->GetPointer(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)})) = ${instr.op0AsCode()};"
      MipsOpcode.Lwc1 -> "${instr.op0AsCode()} = *(float*)(mem->GetPointer(${instr.op1AsCode(S32)} + ${instr.op2AsCode(S32)}));"
      MipsOpcode.FpuBc1f -> recompileBranch("==", CTX_FCOND, "0")
      MipsOpcode.FpuBc1fl -> recompileBranchLikely("==", CTX_FCOND, "0")
      MipsOpcode.FpuBc1t -> recompileBranch("!=", CTX_FCOND, "0")
      MipsOpcode.FpuBc1tl -> recompileBranchLikely("!=", CTX_FCOND, "0")

      // Misc
      MipsOpcode.Movz -> "${instr.op0AsCode()} = ${instr.op2AsCode()} == 0 ? ${instr.op1AsCode()} : ${instr.op0AsCode()};"
      MipsOpcode.Movn -> "${instr.op0AsCode()} = ${instr.op2AsCode()} != 0 ? ${instr.op1AsCode()} : ${instr.op0AsCode()};"
      MipsOpcode.Lui -> "${instr.op0AsCode()} = ${instr.op1AsCode()} << 16;"
      MipsOpcode.Clo -> "${instr.op0AsCode()} = CLO(${instr.op1AsCode()});"
      MipsOpcode.Clz -> "${instr.op0AsCode()} = CLZ(${instr.op1AsCode()});"
      MipsOpcode.Nop -> "// nop"
      MipsOpcode.Cache -> "// cache op"
      MipsOpcode.Break -> "$RUNTIME_PANIC(\"Break instruction: ${instr.op0AsImm().toHex()}\");"
      MipsOpcode.Seb -> "${instr.op0AsCode()} = ((s32)${instr.op1AsCode()} & 0xFF);"
      MipsOpcode.Seh -> "${instr.op0AsCode()} = ((s32)${instr.op1AsCode()} & 0xFFFF);"

      // Branches
      MipsOpcode.Beq -> recompileBranch("==")
      MipsOpcode.Beql -> recompileBranchLikely("==")
      MipsOpcode.Bne -> recompileBranch("!=")
      MipsOpcode.Bnel -> recompileBranchLikely("!=")
      MipsOpcode.Bgez -> recompileBranch(">=", secondArgument = "0")
      MipsOpcode.Bgezl -> recompileBranchLikely(">=", secondArgument = "0")
      MipsOpcode.Bgtz -> recompileBranch(">", secondArgument = "0")
      MipsOpcode.Bgtzl -> recompileBranchLikely(">", secondArgument = "0")
      MipsOpcode.Blez -> recompileBranch("<=", secondArgument = "0")
      MipsOpcode.Blezl -> recompileBranchLikely("<=", secondArgument = "0")
      MipsOpcode.Bltz -> recompileBranch("<", secondArgument = "0")
      MipsOpcode.Bltzl -> recompileBranchLikely("<", secondArgument = "0")

      // Jumps
      MipsOpcode.J -> {
        val hasTarget = instrs.any { it.addr == instr.op0AsImm() }
        "${recompileDelaySlotInstr()}\n" + if (hasTarget) "goto l_${instr.op0AsImm().toHex()};" else "$RUNTIME_PANIC(\"Jump outside function\");"
      }
      MipsOpcode.Jr -> {
        if (instr.op0AsReg() == GprReg.Ra) {
          "${recompileDelaySlotInstr()}\n${postHookCode}return;"
        } else {
          "${recompileDelaySlotInstr()}\n" + generateSwitch(instr, switches[instr.addr] ?: error("Missing switch for $instr"))
        }
      }
      MipsOpcode.Jal -> {
        if (instr.op0AsImm() == 0) {
          "${recompileDelaySlotInstr()}\n$RUNTIME_PANIC(\"jal to 0 address\");"
        } else {
          val targetName = ghidraFunctions.find { it.entryPoint.toInt() == instr.op0AsImm() }?.compatibleName()
            ?: error("Missing function for jal at $instr")
          "${recompileDelaySlotInstr()}\n${targetName}($CALL_ARGS);"
        }
      }
      MipsOpcode.Jalr -> {
        if (instr.op0AsReg() != GprReg.Ra) {
          error("Unsupported jalr to non ra register at $instr")
        }
        """temp = ${instr.op1AsCode()};
${recompileDelaySlotInstr()}
$CALL_INDIRECT($CALL_ARGS, temp);"""
      }

      else -> when {
        failOnUnsupportedOpcode -> error("Unsupported opcode in $instr")
        else -> "Unsupported opcode: ${instr.opcode.mnemonic}".let { msg ->
          println("WARN: $msg")
          "$RUNTIME_PANIC(\"$msg\");"
        }
      }
    }
  }

  private fun generateSwitch(instr: MipsInstr, switch: RecoveredSwitch): String {
    return """switch(${instr.op0AsCode()}) {
${
      switch.cases.map { it.targetAddress }
        .distinct()
        .joinToString("\n") { "case ${it.toHex()}:\n  goto l_${it.toHex()};" }
        .prependIndent("  ")
    }
  default:
    $RUNTIME_PANIC("Impossible switch case at ${instr.addr.toHex()}");
}
"""
  }

  private data class RecompiledFunction(
    private val mode: Mode,
    private val ghidraFunction: GhidraFunction,
    private val recompiledInstrs: List<RecompiledInstr> = emptyList(),
    private val typedReimplementation: TypedReimplementation? = null,
    private val preHook: Boolean = false,
  ) {
    enum class Mode {
      TYPED_REIMPLEMENT,
      EMPTY_BODY,
      WARN_VFPU,
      WARN_NO_OP,
      RECOMPILE,
    }

    fun toCode(): String {
      return when (mode) {
        Mode.TYPED_REIMPLEMENT -> """// ${ghidraFunction.entryPoint.toInt().toHex()}
void ${ghidraFunction.compatibleName()}($CALL_ARGS_DEFINITION) {
${typedReimplementation?.toImplementationCode()?.prependIndent("  ") ?: error("Typed reimplementation must be provided for mode $mode")}
}"""
        Mode.EMPTY_BODY -> """// ${ghidraFunction.entryPoint.toInt().toHex()}
void ${ghidraFunction.compatibleName()}($CALL_ARGS_DEFINITION) {
  // Code generation was disabled for this function in the recompiler configuration
}"""
        Mode.WARN_VFPU -> """// ${ghidraFunction.entryPoint.toInt().toHex()}
void ${ghidraFunction.compatibleName()}($CALL_ARGS_DEFINITION) {
  $RUNTIME_LOG(LOG_LEVEL_WARN, "Function %s using VFPU must be reimplemented", "${ghidraFunction.compatibleName()}");
}"""
        Mode.WARN_NO_OP -> """// ${ghidraFunction.entryPoint.toInt().toHex()}
void ${ghidraFunction.compatibleName()}($CALL_ARGS_DEFINITION) {
  $RUNTIME_LOG(LOG_LEVEL_INFO, "No-op function %s might be imported function", "${ghidraFunction.compatibleName()}");
}"""
        Mode.RECOMPILE -> """// ${ghidraFunction.entryPoint.toInt().toHex()}
void ${ghidraFunction.compatibleName()}($CALL_ARGS_DEFINITION) {
  $RUNTIME_LOG(LOG_LEVEL_TRACE, "Executing %s", "${ghidraFunction.compatibleName()}");${createPreHookCode(ghidraFunction)}
  u32 branchCond;
  u32 temp;
  u64 temp64;
${recompiledInstrs.joinToString("\n") { it.toCode().prependIndent("  ") }}
}"""
      }
    }

    private fun createPreHookCode(ghidraFunction: GhidraFunction): String {
      if (!preHook) {
        return ""
      }
      return "\n  ${ghidraFunction.compatibleName()}_preHook($CALL_ARGS);"
    }
  }

  private data class RecompiledInstr(
    private val instr: MipsInstr,
    private val code: String,
    private val labelNeeded: Boolean,
  ) {
    fun toCode(): String {
      return "${if (labelNeeded) "l_${instr.addr.toHex()}:;\n" else ""}// $instr\n$code"
    }
  }

  private data class TypedReimplementation(
    val ghidraFunction: GhidraFunction,
    val args: List<ReimplementationArg>,
    val result: ReimplementationResult
  ) {
    fun toDefinitionCode(): String {
      return "${result.type.displayName} ${ghidraFunction.compatibleName()}(${args.joinToString(",") { it.type.displayName }});"
    }

    fun toImplementationCode(): String {
      return """${result.asVariableCode()}${ghidraFunction.compatibleName()}(${args.joinToString(",") { it.asReadCode() }});
${result.asWriteCode()}""".trimEnd()
    }
  }

  private data class RecoveredSwitch(
    val dataOffset: Int,
    val cases: List<SwitchCase>
  )

  private data class SwitchCase(
    val number: Int,
    val targetAddress: Int
  )
}

private fun MipsInstr.branchTakenPc(): Int {
  if (!hasFlag(Branch)) {
    error("$this is not a branch instruction")
  }
  return (operands.last { it is ImmOperand } as ImmOperand).value
}

private sealed interface ReimplementationArg {
  data class Regs(
    override val type: GhidraType,
    private val regLo: Reg,
    private val regHi: Reg?
  ) : ReimplementationArg {
    override fun asValueCode(castType: String): String {
      return when (regHi) {
        null -> "(${castType})${regLo.asCode()}"
        else -> "((${castType})${regHi.asCode()} << 32 | ${regLo.asCode()})"
      }
    }
  }

  data class Stack(
    override val type: GhidraType,
    private val offset: Int,
    private val length: Int,
  ) : ReimplementationArg {
    override fun asValueCode(castType: String): String {
      return "(${castType})mem->Read32(${GprReg.Sp.asCode()} + ${offset.toHex()})"
    }
  }

  val type: GhidraType

  fun asReadCode(): String {
    return when (type.kind) {
      GhidraType.Kind.POINTER -> "(${type.displayName})mem->GetPointer(${asValueCode("u32")})"
      else -> asValueCode()
    }
  }

  fun asValueCode(castType: String = type.displayName): String
}

private data class ReimplementationResult(val type: GhidraType) {
  fun asVariableCode(): String {
    return when (type.length) {
      0 -> ""
      4, 8 -> "${type.displayName} result = "
      else -> invalidTypeForReturn()
    }
  }

  fun asWriteCode(): String {
    if (type.kind == GhidraType.Kind.POINTER) {
      return "${GprReg.V0.asCode()} = mem->GetAddress(result);"
    }
    return when (type.length) {
      0 -> ""
      4 -> "${GprReg.V0.asCode()} = (u32)result;"
      8 -> "${GprReg.V0.asCode()} = (u32)result;\n${GprReg.V1.asCode()} = (u32)((u64)result >> 32);"
      else -> invalidTypeForReturn()
    }
  }

  private fun invalidTypeForReturn(): Nothing {
    error("Unsupported length ${type.length} for function return type, type is $type")
  }
}

private fun MipsInstr.op0AsCode(typeCast: TypeCast? = null) = operands[0].asCode(typeCast)

private fun MipsInstr.op1AsCode(typeCast: TypeCast? = null) = operands[1].asCode(typeCast)

private fun MipsInstr.op2AsCode(typeCast: TypeCast? = null) = operands[2].asCode(typeCast)

private fun Operand.asCode(typeCast: TypeCast? = null): String {
  return when (this) {
    is RegOperand -> reg.asCode(typeCast)
    is ImmOperand -> if (typeCast != null) "(${typeCast.code})${value.toHex()}" else value.toHex()
    else -> error("Unknown operand type: $this")
  }
}

private fun Reg.asCode(typeCast: TypeCast? = null): String {
  return when (this) {
    GprReg.Zero -> "0"
    is FpuReg -> {
      if (typeCast != null) {
        error("Type cast specified for FPU register")
      }
      "ctx->fpu.${name}"
    }
    else -> if (typeCast != null) "(${typeCast.code})ctx->gpr.${name}" else "ctx->gpr.${name}"
  }
}

private enum class TypeCast(val code: String) {
  S32("s32"),
  S64("s64"),
  U64("u64"),
}

private fun GhidraFunction.targetObjectName() = compatibleName()
  .split("_", limit = 2)
  .takeIf { it.size == 2 }
  ?.get(0)
  ?.takeIf { it.isNotBlank() }
  ?.lowercase()
  ?: "uncategorized"

private fun GhidraFunction.compatibleName() = name
  .replace("?", "_")
  .replace(":", "_")

private fun GhidraFunction.minAddress() = addressRanges.minOf { it.minAddress }

private fun GhidraFunction.maxAddress() = addressRanges.maxOf { it.maxAddress }

private fun File.writeTextIfDifferent(text: String, charset: Charset = Charsets.UTF_8) {
  if (!exists() || readText(charset) != text) {
    writeText(text, charset)
  }
}
